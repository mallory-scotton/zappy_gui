///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Network/Socket.hpp"
#include "Game/Inventory.hpp"
#include "Game/Team.hpp"
#include "Utils/Singleton.hpp"
#include "Game/Message.hpp"
#include <vector>
#include <unordered_map>
#include <string>
#include <functional>
#include <sstream>
#include <deque>
#include <tuple>
#include <mutex>
#include <atomic>
#include <condition_variable>

///////////////////////////////////////////////////////////////////////////////
// Namespace Zappy
///////////////////////////////////////////////////////////////////////////////
namespace Zappy
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class GameState : public Singleton<GameState>
{
public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    class ScopedLock
    {
    private:
        ///////////////////////////////////////////////////////////////////////
        // Private members
        ///////////////////////////////////////////////////////////////////////
        const GameState& m_gameState;

    public:
        ///////////////////////////////////////////////////////////////////////
        /// \brief
        ///
        /// \param gs The GameState instance to lock
        ///
        ///////////////////////////////////////////////////////////////////////
        explicit ScopedLock(const GameState& gs)
            : m_gameState(gs)
        {
            m_gameState.Lock();
        }

        ///////////////////////////////////////////////////////////////////////
        /// \brief Destructor
        ///
        ///////////////////////////////////////////////////////////////////////
        ~ScopedLock()
        {
            m_gameState.Unlock();
        }
    };

private:
    ///////////////////////////////////////////////////////////////////////////
    // Type alias for command functions
    ///////////////////////////////////////////////////////////////////////////
    using Command = std::function<void(const std::string&)>;

private:
    ///////////////////////////////////////////////////////////////////////////
    // Private members
    ///////////////////////////////////////////////////////////////////////////
    Socket m_socket;                    //<! Network socket for communication
    bool m_isConnected;                 //<! Connection status to the game server
    std::string m_host;                 //<! Host address for the game server
    int m_port;                         //<! Port number for the game server
    std::vector<Inventory> m_tiles;     //<! Tiles in the game state
    std::vector<Team> m_teams;          //<! Teams in the game state
    std::unordered_map<
        std::string,                    //<! Command name
        Command                         //<! Command function
    > m_commands;                       //<! Commands for the game state
    unsigned int m_width;               //<! Width of the game map
    unsigned int m_height;              //<! Height of the game map
    std::deque<Message> m_messages;     //<! Messages in the game state
    unsigned int m_frequency;           //<! Frequency of the game updates
    unsigned int m_livingPlayers;       //<! Number of living players
    unsigned int m_deadPlayers;         //<! Number of dead players
    Inventory m_totalResources;         //<! Total resources in the game state
    std::atomic<bool> m_hasChanged;     //<! Indicate if the game state has changed

    mutable std::recursive_mutex m_mutex; //<! Mutex for thread safety
    std::thread m_networkThread;        //<! Thread for network communication
    std::atomic<bool> m_shouldStop;     //<! Indicate if the network thread should stop
    std::condition_variable_any m_cv;   //<! Condition variable for synchronization

private:
    ///////////////////////////////////////////////////////////////////////////
    // Team colors for visualization
    ///////////////////////////////////////////////////////////////////////////
    const std::vector<sf::Color> m_teamColors =
    {
        sf::Color::Red,
        sf::Color::Blue,
        sf::Color::Green,
        sf::Color::Yellow,
        sf::Color::Magenta,
        sf::Color::Cyan,
        sf::Color(255, 165, 0),   // Orange
        sf::Color(128, 0, 128)    // Purple
    };

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    GameState(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    ~GameState();

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Connect to the game server
    ///
    /// \param host The host address of the game server
    /// \param port The port number of the game server
    ///
    /// \return True if the connection was successful, false otherwise
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool Connect(const std::string& host, int port);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Disconnect from the game server
    ///
    ///////////////////////////////////////////////////////////////////////////
    void Disconnect(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Start the network thread for handling incoming messages
    ///
    ///////////////////////////////////////////////////////////////////////////
    void StartNetworkThread(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Stop the network thread
    ///
    ///////////////////////////////////////////////////////////////////////////
    void StopNetworkThread(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Process a command from the game server
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ResetChanged(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Lock the game state for thread safety
    ///
    ///////////////////////////////////////////////////////////////////////////
    void Lock(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Unlock the game state after thread safety operations
    ///
    ///////////////////////////////////////////////////////////////////////////
    void Unlock(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the dimensions of the game map
    ///
    /// \return A tuple containing the width and height of the game map
    ///
    ///////////////////////////////////////////////////////////////////////////
    std::tuple<unsigned int, unsigned int> GetDimensions(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the width of the game map
    ///
    /// \return The width of the game map
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetWidth(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the height of the game map
    ///
    /// \return The height of the game map
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetHeight(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the tile at the specified coordinates
    ///
    /// \param x The x-coordinate of the tile
    /// \param y The y-coordinate of the tile
    ///
    /// \return A reference to the Inventory object at the specified tile
    ///
    ///////////////////////////////////////////////////////////////////////////
    const Inventory& GetTileAt(unsigned int x, unsigned int y) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get all tiles in the game state
    ///
    /// \return A vector containing all Inventory objects representing the
    /// tiles
    ///
    ///////////////////////////////////////////////////////////////////////////
    const std::vector<Inventory>& GetTiles(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get all teams in the game state
    ///
    /// \return A vector containing all Team objects
    ///
    ///////////////////////////////////////////////////////////////////////////
    const std::vector<Team>& GetTeams(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get all messages in the game state
    ///
    /// \return A vector containing all Message objects
    ///
    ///////////////////////////////////////////////////////////////////////////
    const std::deque<Message>& GetMessages(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the total resources in the game state
    ///
    /// \return A reference to the Inventory object representing the total
    ///
    ///////////////////////////////////////////////////////////////////////////
    const Inventory& GetTotalResources(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the frequency of the game updates
    ///
    /// \return The frequency of the game updates
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetFrequency(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the number of living players in the game state
    ///
    /// \return The number of living players
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetLivingPlayers(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the number of dead players in the game state
    ///
    /// \return The number of dead players
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetDeadPlayers(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the player by ID
    ///
    /// \param x The x-coordinate of the tile
    /// \param y The y-coordinate of the tile
    ///
    /// \return A vector of references to Player objects at the specified tile
    ///
    ///////////////////////////////////////////////////////////////////////////
    std::vector<const Player*> GetPlayersAt(
        unsigned int x, unsigned int y
    ) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Check if the game state has changed
    ///
    /// \return True if the game state has changed, false otherwise
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool HasChanged(void) const;

private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Process a command from the game server
    ///
    ///////////////////////////////////////////////////////////////////////////
    void NetworkThreadFunction(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Process incoming network messages
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ProcessNetworkMessages(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseMSZ(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseBCT(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseTNA(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePNW(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePPO(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePLV(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePIN(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePEX(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePBC(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePIC(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePIE(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePFK(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePDR(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePGT(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePDI(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseENW(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseEBO(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseEDI(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSGT(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSST(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSEG(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSMG(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSUC(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSBP(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param iss
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Player& GetPlayerByID(std::istringstream& iss);
};

} // !namespace Zappy
