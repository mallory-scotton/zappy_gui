///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include "Network/Socket.hpp"
#include "Game/Inventory.hpp"
#include "Game/Team.hpp"
#include "Utils/Singleton.hpp"
#include "Game/Message.hpp"
#include <vector>
#include <unordered_map>
#include <string>
#include <functional>
#include <sstream>
#include <tuple>

///////////////////////////////////////////////////////////////////////////////
// Namespace Zappy
///////////////////////////////////////////////////////////////////////////////
namespace Zappy
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class GameState : public Singleton<GameState>
{
private:
    ///////////////////////////////////////////////////////////////////////////
    // Type alias for command functions
    ///////////////////////////////////////////////////////////////////////////
    using Command = std::function<void(const std::string&)>;

private:
    ///////////////////////////////////////////////////////////////////////////
    // Private members
    ///////////////////////////////////////////////////////////////////////////
    Socket m_socket;                    //<! Network socket for communication
    bool m_isConnected;                 //<! Connection status to the game server
    std::string m_host;                 //<! Host address for the game server
    int m_port;                         //<! Port number for the game server
    std::vector<Inventory> m_tiles;     //<! Tiles in the game state
    std::vector<Team> m_teams;          //<! Teams in the game state
    std::unordered_map<
        std::string,                    //<! Command name
        Command                         //<! Command function
    > m_commands;                       //<! Commands for the game state
    unsigned int m_width;               //<! Width of the game map
    unsigned int m_height;              //<! Height of the game map
    std::vector<Message> m_messages;    //<! Messages in the game state
    unsigned int m_frequency;           //<! Frequency of the game updates
    unsigned int m_livingPlayers;       //<! Number of living players
    unsigned int m_deadPlayers;         //<! Number of dead players

private:
    ///////////////////////////////////////////////////////////////////////////
    // Team colors for visualization
    ///////////////////////////////////////////////////////////////////////////
    const std::vector<sf::Color> m_teamColors =
    {
        sf::Color::Red,
        sf::Color::Blue,
        sf::Color::Green,
        sf::Color::Yellow,
        sf::Color::Magenta,
        sf::Color::Cyan,
        sf::Color(255, 165, 0),   // Orange
        sf::Color(128, 0, 128)    // Purple
    };

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    GameState(void);

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief Connect to the game server
    ///
    /// \param host The host address of the game server
    /// \param port The port number of the game server
    ///
    /// \return True if the connection was successful, false otherwise
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool Connect(const std::string& host, int port);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Update the game state
    ///
    ///////////////////////////////////////////////////////////////////////////
    void Update(void);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the dimensions of the game map
    ///
    /// \return A tuple containing the width and height of the game map
    ///
    ///////////////////////////////////////////////////////////////////////////
    std::tuple<unsigned int, unsigned int> GetDimensions(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the width of the game map
    ///
    /// \return The width of the game map
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetWidth(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the height of the game map
    ///
    /// \return The height of the game map
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetHeight(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the tile at the specified coordinates
    ///
    /// \param x The x-coordinate of the tile
    /// \param y The y-coordinate of the tile
    ///
    /// \return A reference to the Inventory object at the specified tile
    ///
    ///////////////////////////////////////////////////////////////////////////
    const Inventory& GetTileAt(unsigned int x, unsigned int y) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get all tiles in the game state
    ///
    /// \return A vector containing all Inventory objects representing the
    /// tiles
    ///
    ///////////////////////////////////////////////////////////////////////////
    const std::vector<Inventory>& GetTiles(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get all teams in the game state
    ///
    /// \return A vector containing all Team objects
    ///
    ///////////////////////////////////////////////////////////////////////////
    const std::vector<Team>& GetTeams(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get all messages in the game state
    ///
    /// \return A vector containing all Message objects
    ///
    ///////////////////////////////////////////////////////////////////////////
    const std::vector<Message>& GetMessages(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the frequency of the game updates
    ///
    /// \return The frequency of the game updates
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetFrequency(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the number of living players in the game state
    ///
    /// \return The number of living players
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetLivingPlayers(void) const;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the number of dead players in the game state
    ///
    /// \return The number of dead players
    ///
    ///////////////////////////////////////////////////////////////////////////
    unsigned int GetDeadPlayers(void) const;

private:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseMSZ(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseBCT(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseTNA(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePNW(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePPO(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePLV(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePIN(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePEX(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePBC(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePIC(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePIE(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePFK(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePDR(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePGT(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParsePDI(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseENW(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseEBO(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseEDI(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSGT(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSST(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSEG(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSMG(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSUC(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param msg
    ///
    ///////////////////////////////////////////////////////////////////////////
    void ParseSBP(const std::string& msg);

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param iss
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Player& GetPlayerByID(std::istringstream& iss);
};

} // !namespace Zappy
